<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用sharding jdbc从oracle中导出数据并分表存储在mysql中</title>
    <url>/2020/06/11/%E4%BD%BF%E7%94%A8sharding%20jdbc%E4%BB%8Eoracle%E4%B8%AD%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%88%86%E8%A1%A8%E5%AD%98%E5%82%A8%E5%9C%A8mysql%E4%B8%AD/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><pre><code>业务系统的数据放在oracle中,不方便做报表人员分析数据,于是准备把oracle中的数据同步到mysql中做一些简单处理并按照年分表</code></pre>
<a id="more"></a>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="引入maven依赖"><a href="#引入maven依赖" class="headerlink" title="引入maven依赖"></a>引入maven依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shardingsphere&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.0-RC1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;                    </span><br></pre></td></tr></table></figure>


<h4 id="sharding-jdbc-配置"><a href="#sharding-jdbc-配置" class="headerlink" title="sharding jdbc 配置"></a>sharding jdbc 配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  shardingsphere:</span><br><span class="line">    datasource: </span><br><span class="line">      names: mysql</span><br><span class="line">      mysql:</span><br><span class="line">        username: root</span><br><span class="line">        password: 123456</span><br><span class="line">        type: com.zaxxer.hikari.HikariDataSource</span><br><span class="line">        driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">        jdbc-url: jdbc:mysql:&#x2F;&#x2F;192.168.11.85:3306&#x2F;data-analysis?allowMultiQueries&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;useSSL&#x3D;false&amp;serverTimezone&#x3D;GMT%2B8</span><br><span class="line">    sharding:</span><br><span class="line">      tables:</span><br><span class="line">        orders:</span><br><span class="line">          table-strategy: # 分表策略 我这里使用复合分表策略</span><br><span class="line">            complex: </span><br><span class="line">              sharding-columns: create_time,order_status,product_name,buyer_name,link_name</span><br><span class="line">              algorithm-class-name: com.*.*.config.OrdersShardingAlgorithm</span><br><span class="line">          actual-data-nodes: mysql.orders_$&#123;[&#39;2017_2019&#39;,&#39;error&#39;,&#39;free&#39;,&#39;2020&#39;,&#39;2021&#39;,&#39;2022&#39;,&#39;2023&#39;,&#39;2024&#39;,&#39;2025&#39;]&#125;    # 这是数据建好的表  表名 就是orders_2020            </span><br></pre></td></tr></table></figure>

<h4 id="oracle-数据源配置"><a href="#oracle-数据源配置" class="headerlink" title="oracle 数据源配置"></a>oracle 数据源配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">datasource:</span><br><span class="line">  oracle:</span><br><span class="line">    username: 121</span><br><span class="line">    password: 121</span><br><span class="line">    driverClassName: oracle.jdbc.driver.OracleDriver</span><br><span class="line">    url: jdbc:oracle:thin:@127.0.0.1:orcl</span><br></pre></td></tr></table></figure>
<h4 id="配置oracle数据源"><a href="#配置oracle数据源" class="headerlink" title="配置oracle数据源"></a>配置oracle数据源</h4><pre><code>这里获取oracle中的数据是使用的自定义的jdbcTemplate ，而同步到mysql中的用的是mybatis plus </code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.*.data.properties.OracleDataSourceProperties;</span><br><span class="line">import com.zaxxer.hikari.HikariDataSource;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">   </span><br><span class="line">@Configuration</span><br><span class="line">public class OracleDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    private OracleDataSourceProperties oracleDataSourceProperties;</span><br><span class="line"></span><br><span class="line">    @Bean(&quot;oracle&quot;)</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        HikariDataSource hikariDataSource &#x3D; new HikariDataSource();</span><br><span class="line">        hikariDataSource.setUsername(oracleDataSourceProperties.getUsername());</span><br><span class="line">        hikariDataSource.setPassword(oracleDataSourceProperties.getPassword());</span><br><span class="line">        hikariDataSource.setDriverClassName(oracleDataSourceProperties.getDriverClassName());</span><br><span class="line">        hikariDataSource.setJdbcUrl(oracleDataSourceProperties.getUrl());</span><br><span class="line">        return hikariDataSource;</span><br><span class="line">    &#125; </span><br><span class="line">    @Bean()</span><br><span class="line">    public JdbcTemplate jdbcTemplate() &#123;</span><br><span class="line">        JdbcTemplate jdbcTemplate &#x3D; new JdbcTemplate();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource());</span><br><span class="line">        return jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="分表策略"><a href="#分表策略" class="headerlink" title="分表策略"></a>分表策略</h4><pre><code>我这里要区分数据的规则有很多，所以我使用了复合分片策略</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import org.apache.shardingsphere.api.sharding.complex.ComplexKeysShardingAlgorithm;</span><br><span class="line">import org.apache.shardingsphere.api.sharding.complex.ComplexKeysShardingValue;</span><br><span class="line">import org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class OrdersShardingAlgorithm implements ComplexKeysShardingAlgorithm &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Collection&lt;String&gt; doSharding(Collection availableTargetNames, ComplexKeysShardingValue shardingValue) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; shardingResults &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        String logicTableName &#x3D; shardingValue.getLogicTableName();</span><br><span class="line">        Map&lt;String, Collection&gt; valuesMap &#x3D; shardingValue.getColumnNameAndShardingValuesMap();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 这里自定了一个bean  用来装分片策略键的value</span><br><span class="line">        ConvertBean convertBean &#x3D; new ConvertBean();</span><br><span class="line">        </span><br><span class="line">        valuesMap.forEach((k, v) -&gt; &#123;</span><br><span class="line">            String value &#x3D; v.stream().findFirst().get().toString();</span><br><span class="line">            if (k.equals(&quot;order_status&quot;)) &#123;</span><br><span class="line">                convertBean.setOrderStatus(value);</span><br><span class="line">            &#125;</span><br><span class="line">            if (k.equals(&quot;create_time&quot;)) &#123;</span><br><span class="line">                convertBean.setCreateTime(LocalDateTime.parse(value));</span><br><span class="line">            &#125;</span><br><span class="line">            if (k.equals(&quot;product_name&quot;)) &#123;</span><br><span class="line">                convertBean.setProductName(value);</span><br><span class="line">            &#125;</span><br><span class="line">            if (k.equals(&quot;buyer_name&quot;)) &#123;</span><br><span class="line">                convertBean.setBuyerName(value);</span><br><span class="line">            &#125;</span><br><span class="line">            if (k.equals(&quot;link_name&quot;)) &#123;</span><br><span class="line">                convertBean.setLinkName(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; 这里就是判断每一条数据要进入哪一张表</span><br><span class="line">        if (StringUtils.hasText(convertBean.getProductName()) &amp;&amp; (convertBean.getProductName().contains(&quot;惠民&quot;) || convertBean.getProductName().contains(&quot;测试&quot;))) &#123;</span><br><span class="line">            shardingResults.add(logicTableName + &quot;_&quot; + &quot;free&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (convertBean.getOrderStatus().equals(&quot;3&quot;)) &#123;</span><br><span class="line">                LocalDateTime create_time &#x3D; convertBean.getCreateTime();</span><br><span class="line">                int year &#x3D; create_time.getYear();</span><br><span class="line">                LocalDateTime parse &#x3D; LocalDateTime.of(2020, 1, 1, 0, 0);</span><br><span class="line">                if (create_time.isBefore(parse)) &#123;</span><br><span class="line">                    shardingResults.add(logicTableName + &quot;_&quot; + 2017 + &quot;_&quot; + 2019);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    shardingResults.add(logicTableName + &quot;_&quot; + year);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                shardingResults.add(logicTableName + &quot;_&quot; + &quot;error&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return shardingResults;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><pre><code>使用只需要 注入 jdbcTemplate 就可以了</code></pre>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">@Override</span><br><span class="line">public List&lt;OrderInfo&gt; List(String startDate, String endDate, int num, int pageSize) &#123;</span><br><span class="line">    &#x2F;&#x2F; sql  定义好用query 查询就可以了</span><br><span class="line">    String sql &#x3D; &quot;select * from order_test&quot;; </span><br><span class="line">    BeanPropertyRowMapper&lt;OrderInfo&gt; orderInfoBeanPropertyRowMapper &#x3D; BeanPropertyRowMapper.newInstance(OrderInfo.class);</span><br><span class="line">    return jdbcTemplate.query(sql, orderInfoBeanPropertyRowMapper);</span><br><span class="line">&#125;   </span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<pre><code>查出来的数据就可以通过mybatis plus 存入mysql中了 
mysql的数据源交给 sharding jdbc 托管，就会走分表规则</code></pre>
<p>基本上只需要配置这么多就够了 </p>
<blockquote><footer><strong>demo 地址</strong><cite><a href="https://github.com/thtns/sharding-jdbc-demo">github.com/thtns/sharding-jdbc-demo</a></cite></footer></blockquote>
]]></content>
      <tags>
        <tag>spring boot</tag>
        <tag>sharding jdbc</tag>
        <tag>jdbcTemplate</tag>
        <tag>mybatis plus</tag>
      </tags>
  </entry>
</search>
